var documenterSearchIndex = {"docs":
[{"location":"#PMFRG.jl.","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"","category":"section"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"Function Documentation","category":"page"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.BS3","category":"page"},{"location":"#OrdinaryDiffEq.BS3","page":"PMFRG.jl.","title":"OrdinaryDiffEq.BS3","text":"BS3(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False(),)\n\nExplicit Runge-Kutta Method. A third-order, four-stage explicit FSAL Runge-Kutta method with embedded error estimator of Bogacki and Shampine.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on  appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(),  default) or use multiple threads (thread = OrdinaryDiffEq.True()) when  Julia is started with multiple threads.\n\nReferences\n\n@article{bogacki19893,     title={A 3 (2) pair of Runge-Kutta formulas},     author={Bogacki, Przemyslaw and Shampine, Lawrence F},     journal={Applied Mathematics Letters},     volume={2},     number={4},     pages={321–325},     year={1989},     publisher={Elsevier}     }\n\n\n\n\n\n","category":"type"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.BSE_iteration! ","category":"page"},{"location":"#PMFRG.BSE_iteration!","page":"PMFRG.jl.","title":"PMFRG.BSE_iteration!","text":"Performs single BSE iteration. Specify State explicitly to make fixed point libraries compatible (even though it may point to the same memory location as Workspace.State) \n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.BareVertexType","category":"page"},{"location":"#PMFRG.BareVertexType","page":"PMFRG.jl.","title":"PMFRG.BareVertexType","text":"Stores all information about the bare vertex (without frequencies)\n\n\n\n\n\n","category":"type"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.BareVertex_Freq ","category":"page"},{"location":"#PMFRG.BareVertex_Freq","page":"PMFRG.jl.","title":"PMFRG.BareVertex_Freq","text":"Allocates a frequency-dependent vertex type and initializes it with the bare vertex\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.BubbleType","category":"page"},{"location":"#PMFRG.BubbleType","page":"PMFRG.jl.","title":"PMFRG.BubbleType","text":"Struct storing information about Bubble functions, i.e. rhs derivatives of vertex flow equations.\n\n\n\n\n\n","category":"type"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.DP5","category":"page"},{"location":"#OrdinaryDiffEq.DP5","page":"PMFRG.jl.","title":"OrdinaryDiffEq.DP5","text":"DP5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False(),)\n\nExplicit Runge-Kutta Method. Dormand-Prince's 5/4 Runge-Kutta method. (free 4th order interpolant).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on  appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(),  default) or use multiple threads (thread = OrdinaryDiffEq.True()) when  Julia is started with multiple threads.\n\nReferences\n\n@article{dormand1980family,     title={A family of embedded Runge-Kutta formulae},     author={Dormand, John R and Prince, Peter J},     journal={Journal of computational and applied mathematics},     volume={6},     number={1},     pages={19–26},     year={1980},     publisher={Elsevier}     }\n\n\n\n\n\n","category":"type"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.Lam_to_t ","category":"page"},{"location":"#PMFRG.Lam_to_t","page":"PMFRG.jl.","title":"PMFRG.Lam_to_t","text":"Converts physical cutoff Λ to t (integrator step). Inverse of ttoLam.\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.MultiLoopWorkSpace","category":"page"},{"location":"#PMFRG.MultiLoopWorkSpace","page":"PMFRG.jl.","title":"PMFRG.MultiLoopWorkSpace","text":"Struct containing all memory used in a single ODE step \n\n\n\n\n\n","category":"type"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.NumericalParams","category":"page"},{"location":"#PMFRG.NumericalParams","page":"PMFRG.jl.","title":"PMFRG.NumericalParams","text":"Struct to hold all relevant quantities that are needed throughout the computation. \n\nN::Int = 24\nNgamma::Int = 100 #Number of gamma frequencies\nVDims::NTuple{4,Int} = (Npairs,N,N,N)\naccuracy::Float64 = 1e-6\nLam_min::Float64 = exp(-10.),\nLam_max::Float64 = exp(10.),\nusesymmetry::Bool = true\nMinimalOutput::Bool = false\nex_freq::Float64 = (2*N-1)*pi*T\nlenIntw::Int = N\nlenIntw_acc::Int = 2*maximum((N,Ngamma,lenIntw)) # more accurate for less demanding sums\nnp_vec::Array{Int,1} = collect(0:N-1)\nnp_vec_gamma::Array{Int,1} = collect(0:Ngamma-1)\n\n\n\n\n\n","category":"type"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.Observables","category":"page"},{"location":"#PMFRG.Observables","page":"PMFRG.jl.","title":"PMFRG.Observables","text":"Struct containing the observables that are saved at every step\n\n\n\n\n\n","category":"type"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.OneLoopWorkspace","category":"page"},{"location":"#PMFRG.OneLoopWorkspace","page":"PMFRG.jl.","title":"PMFRG.OneLoopWorkspace","text":"Convenience struct containing references to arrays for vertices and their derivative. This does not allocate any memory and is performant. \n\n\n\n\n\n","category":"type"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.PMFRGParams","category":"page"},{"location":"#PMFRG.PMFRGParams","page":"PMFRG.jl.","title":"PMFRG.PMFRGParams","text":"Abstract Param struct to dispatch between different PMFRG methods (i.e. Two-Loop or Parquet) Assumed to have at least the fields: System::Geometry NumericalParams::NumericalParams Options\n\n\n\n\n\n","category":"type"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.Params","category":"page"},{"location":"#PMFRG.Params","page":"PMFRG.jl.","title":"PMFRG.Params","text":"Construct a set of parameters used for an FRG calculation. 'System' refers to the geometry that is used for the calculation (see SpinFRGLattices). The second argument is the method, i.e. OneLoop() (default value), TwoLoop(), Parquet(). For possible optional keyword arguments see the docs of 'NumericalParams'.\n\n\n\n\n\nParams constructor for parquet calculation. For all available params, see also PMFRG.ParquetOptions and PMFRG.NumericalParams.\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.SetCompletionCheckmark ","category":"page"},{"location":"#PMFRG.SetCompletionCheckmark","page":"PMFRG.jl.","title":"PMFRG.SetCompletionCheckmark","text":"Rename CurrentState to FinalState as indicator that Job is finished\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.SetupParquet","category":"page"},{"location":"#PMFRG.SetupParquet","page":"PMFRG.jl.","title":"PMFRG.SetupParquet","text":"Constructs Workspace for parquet equations. Irreducible vertex can later be provided by optional argument but this is currently not supported \n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.SolveFRG","category":"page"},{"location":"#PMFRG.SolveFRG","page":"PMFRG.jl.","title":"PMFRG.SolveFRG","text":"Given a set of Parameters (currently, oneß and twoloop are implemented), solves the set of differential flow equations and returns the ODE solution object along with an array of Observables at each lambda step. Allowed keyword arguments (with default values):\n\nMainFile = nothing,                             # Specifies name of main output file as a string.\n                                                # Defaults to 'nothing', in which case no output file is produced.\nGroup = DefaultGroup(Par),               # Specifies the name of the subgroup of the main files HDF5 group to which the output data is written. Defaults to temperature\n                                                # Defaults to the value of temperature to allow temperature sweeps to be written to the same file.\nCheckpointDirectory = nothing,                  # Directory in which the current ODE state is written in regular intervals during the integration. \n                                                # Default 'nothing' will not produce any backup!\nmethod = DP5(),                                 # ODE integration method. Standard is set to OrdinaryDiffEq.DP5(). \n                                                # See OrdinaryDiffEq package for further options.\nMaxVal = Inf                                    # Terminates the ODE solution, when any absolute value of the Solution reaches MaxVal.\nObsSaveat = nothing,                            # Specifies a vector of Λ values at which Observables are computed.\nVertexCheckpoints = [],                         # Specifies a vector of Λ values at which vertices shall be saved permanently without being overwritten. \n                                                # Empty means only the current state will be saved. Requires CheckpointDir ≠ nothing !\noverwrite_Checkpoints = false::Bool,            # Specifies whether CheckpointDirectory is to be overwritten if it exists. \n                                                # Defaults to false, in which case an unused name is generated.\nCheckPointSteps = 1,                            # Number of skipped steps before Checkpoint data is saved to reduce time spent on IO operations.\nkwargs...                                       # Additional keyword arguments are passed to OrdinaryDiffEq.solve.\n                                                # See the OrdinaryDiffEq documentation for further details.\n\n\n\n\n\nSolves FRG as specified for parameters\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.StateType","category":"page"},{"location":"#PMFRG.StateType","page":"PMFRG.jl.","title":"PMFRG.StateType","text":"Struct containing information about the (physical) ODE State, i.e. vertices\n\n\n\n\n\n","category":"type"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.TwoLoopWorkspace","category":"page"},{"location":"#PMFRG.TwoLoopWorkspace","page":"PMFRG.jl.","title":"PMFRG.TwoLoopWorkspace","text":"Convenience struct containing references to arrays for vertices and their derivative. This does not allocate any memory and is performant. \n\n\n\n\n\n","category":"type"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.V_ ","category":"page"},{"location":"#PMFRG.V_","page":"PMFRG.jl.","title":"PMFRG.V_","text":"Returns value of vertex, swaps sites i <-> j by reading from inverted pairs when necessary. For performance, it is advised to directly use the Arrays like Va after pre-checking the frequency structure \n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.Vern7","category":"page"},{"location":"#OrdinaryDiffEq.Vern7","page":"PMFRG.jl.","title":"OrdinaryDiffEq.Vern7","text":"Vern7(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False(),\n        lazy = true)\n\nExplicit Runge-Kutta Method. Verner's “Most Efficient” 7/6 Runge-Kutta method. (lazy 7th order interpolant).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on  appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False(),  default) or use multiple threads (thread = OrdinaryDiffEq.True()) when  Julia is started with multiple threads.\nlazy: determines if the lazy interpolant is used.\n\nReferences\n\n@article{verner2010numerically,     title={Numerically optimal Runge–Kutta pairs with interpolants},     author={Verner, James H},     journal={Numerical Algorithms},     volume={53},     number={2-3},     pages={383–396},     year={2010},     publisher={Springer}     }\n\n\n\n\n\n","category":"type"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.VertexType","category":"page"},{"location":"#PMFRG.VertexType","page":"PMFRG.jl.","title":"PMFRG.VertexType","text":"Struct containing information about four-point vertices\n\n\n\n\n\n","category":"type"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG._convertToFloat ","category":"page"},{"location":"#PMFRG._convertToFloat","page":"PMFRG.jl.","title":"PMFRG._convertToFloat","text":"Converts other arguments to type of first argument. If that is not a float, converts everything to Float64.\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.addBR! ","category":"page"},{"location":"#PMFRG.addBR!","page":"PMFRG.jl.","title":"PMFRG.addBR!","text":"adds to ResultBubble given the vertex as well as a bubble inserted on the left. Assumes that vertices and bubbles are given pre-computed in VertexBuffer.\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.addTo1PartBubble! ","category":"page"},{"location":"#PMFRG.addTo1PartBubble!","page":"PMFRG.jl.","title":"PMFRG.addTo1PartBubble!","text":"Computes a single-particle (i.e. self-energy) bubble. Allows specification of function type, i.e. what vertices are used since this is different if a bubble function is inserted as opposed to a vertex.\n\n\n\n\n\nComputes a single-particle (i.e. self-energy) bubble. Can only be used if B is a bubble function\n\n\n\n\n\nComputes a single-particle (i.e. self-energy) bubble. Can only be used if argument is a vertex\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.addTo2PartBubble! ","category":"page"},{"location":"#PMFRG.addTo2PartBubble!","page":"PMFRG.jl.","title":"PMFRG.addTo2PartBubble!","text":"Computes a two-particle bubble in the s-Channel given two four-point functions (i.e. vertices or other bubbles). Γ is assumed to be a vertex. To allow the computation using just the left part of a bubble, specification of the transpose is needed i.e. Transpose(XL) = XR and Transpose(X) = X, where X = XL + XR is the full bubble.\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.addX! ","category":"page"},{"location":"#PMFRG.addX!","page":"PMFRG.jl.","title":"PMFRG.addX!","text":"adds part of X functions in Matsubara sum at nwpr containing the site summation for a set of s t and u frequencies. This is the most numerically demanding part!\n\n\n\n\n\nUse multiple dispatch to treat the common special case in which the propagator does not depend on site indices to increase performance\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.addXTilde! ","category":"page"},{"location":"#PMFRG.addXTilde!","page":"PMFRG.jl.","title":"PMFRG.addXTilde!","text":"Use multiple dispatch to treat the common special case in which the propagator does not depend on site indices to increase performance\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.gamma_ ","category":"page"},{"location":"#PMFRG.gamma_","page":"PMFRG.jl.","title":"PMFRG.gamma_","text":"Returns self energy evaluated at the appropriate frequency\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.getXBubblePartition! ","category":"page"},{"location":"#PMFRG.getXBubblePartition!","page":"PMFRG.jl.","title":"PMFRG.getXBubblePartition!","text":"writing to X and XTilde in Workspace, computes bubble diagrams within a range of frequencies given by isrange, itrange and iurange\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.get_sign_iw ","category":"page"},{"location":"#PMFRG.get_sign_iw","page":"PMFRG.jl.","title":"PMFRG.get_sign_iw","text":"Given a (Matsubara) integer, returns a corresponding signed integer within the considered range\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.get_w ","category":"page"},{"location":"#PMFRG.get_w","page":"PMFRG.jl.","title":"PMFRG.get_w","text":"given a Matsubara (!) integer, return the corresponding Matsubara frequency\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.iG_ ","category":"page"},{"location":"#PMFRG.iG_","page":"PMFRG.jl.","title":"PMFRG.iG_","text":"Taking a Matsubara integer, gives fully dressed propagator\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.iSKat_ ","category":"page"},{"location":"#PMFRG.iSKat_","page":"PMFRG.jl.","title":"PMFRG.iSKat_","text":"Taking a Matsubara integer, gives full single-scale propagator with Katanin (vertex flow equation)\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.iS_ ","category":"page"},{"location":"#PMFRG.iS_","page":"PMFRG.jl.","title":"PMFRG.iS_","text":"Taking a Matsubara integer, gives single-scale propagator without Katanin (self energy flow equation)\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.iterateSDE! ","category":"page"},{"location":"#PMFRG.iterateSDE!","page":"PMFRG.jl.","title":"PMFRG.iterateSDE!","text":"Self-consistently iterates SDE until convergence is reached.\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.iterateSolution! ","category":"page"},{"location":"#PMFRG.iterateSolution!","page":"PMFRG.jl.","title":"PMFRG.iterateSolution!","text":"Obtains a solution to Bethe-Salpeter and Schwinger-Dyson equations by iteration until convergence is reached up to accuracy specified by accuracy in Params\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.joinGroup ","category":"page"},{"location":"#PMFRG.joinGroup","page":"PMFRG.jl.","title":"PMFRG.joinGroup","text":"This file contains functions used for reading and writing FRG data to disc. Stored data can be used to re-launch an incomplete FRG calculation.\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.readState","category":"page"},{"location":"#PMFRG.readState","page":"PMFRG.jl.","title":"PMFRG.readState","text":"Reads Vertices from file\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.saveGeometryParams ","category":"page"},{"location":"#PMFRG.saveGeometryParams","page":"PMFRG.jl.","title":"PMFRG.saveGeometryParams","text":"Saves important information about Geometry parameters so that they can be reconstructed\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.saveNumericalParams ","category":"page"},{"location":"#PMFRG.saveNumericalParams","page":"PMFRG.jl.","title":"PMFRG.saveNumericalParams","text":"Saves important information about computation parameters so that they can be reconstructed\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.saveObs","category":"page"},{"location":"#PMFRG.saveObs","page":"PMFRG.jl.","title":"PMFRG.saveObs","text":"Saves Observables\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.saveParams","category":"page"},{"location":"#PMFRG.saveParams","page":"PMFRG.jl.","title":"PMFRG.saveParams","text":"Saves important information about parameters so that they can be reconstructed\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.saveState","category":"page"},{"location":"#PMFRG.saveState","page":"PMFRG.jl.","title":"PMFRG.saveState","text":"Saves Vertices to a compressed HDF5 file in a Group \"Lam\".\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.setZero! ","category":"page"},{"location":"#PMFRG.setZero!","page":"PMFRG.jl.","title":"PMFRG.setZero!","text":"fills an array with zeros\n\n\n\n\n\nRecursively sets structure to zero\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.squareDist ","category":"page"},{"location":"#PMFRG.squareDist","page":"PMFRG.jl.","title":"PMFRG.squareDist","text":"Computes total difference between two objects of type T by summing up the distance of all elements\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.symmetrizeBubble! ","category":"page"},{"location":"#PMFRG.symmetrizeBubble!","page":"PMFRG.jl.","title":"PMFRG.symmetrizeBubble!","text":"Use symmetries and identities to compute the rest of bubble functions\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.t_to_Lam","category":"page"},{"location":"#PMFRG.t_to_Lam","page":"PMFRG.jl.","title":"PMFRG.t_to_Lam","text":"Converts t step used for integrator to Λ. Inverse of Lamtot.\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"PMFRG.writeTo! ","category":"page"},{"location":"#PMFRG.writeTo!","page":"PMFRG.jl.","title":"PMFRG.writeTo!","text":"Set two objects equal by recusively setting all their fields to be equal\n\n\n\n\n\n","category":"function"},{"location":"","page":"PMFRG.jl.","title":"PMFRG.jl.","text":"SolveParquet","category":"page"},{"location":"#PMFRG.SolveParquet","page":"PMFRG.jl.","title":"PMFRG.SolveParquet","text":"Given set of parameters solve the self-consistent Parquet approximation iteratively.  TODO: Save output to file\n\n\n\n\n\n","category":"function"}]
}
